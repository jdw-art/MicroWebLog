2024-07-22 22:27:03.961 [http-nio-8088-exec-9] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ## HeaderUserId2ContextFilter，用户 ID：1
2024-07-22 22:27:03.961 [http-nio-8088-exec-9] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 设置 userId 到 ThreadLocal 中， 用户 ID: 1
2024-07-22 22:27:03.962 [http-nio-8088-exec-9] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求开始: [前台获取博客详情], 入参: , 请求类: BlogSettingsController, 请求方法: findDetail =================================== 
2024-07-22 22:27:03.965 [http-nio-8088-exec-9] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求结束: [前台获取博客详情], 耗时: 3ms, 出参: {"success":true,"message":null,"errorCode":null,"data":{"logo":"http://110.41.141.141:9000/weblog/weblog/9853f8be13cb4f7fae00e3f5233dd688.png","name":"WebLog","author":"Jacob","introduction":"求知若饥，虚心若愚","avatar":"http://110.41.141.141:9000/weblog/weblog/cf0958d87787449fb05aae4cc84015c6.jpg","githubHomepage":"https://github.com/jdw-art","csdnHomepage":"https://www.csdn.net/?spm=1010.2135.3001.4476","giteeHomepage":"","zhihuHomepage":"https://www.zhihu.com/people/54-10-50-93"}} =================================== 
2024-07-22 22:27:03.966 [http-nio-8088-exec-9] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 删除 ThreadLocal， userId: 1
2024-07-22 22:27:03.981 [http-nio-8088-exec-8] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ## HeaderUserId2ContextFilter，用户 ID：1
2024-07-22 22:27:03.981 [http-nio-8088-exec-8] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 设置 userId 到 ThreadLocal 中， 用户 ID: 1
2024-07-22 22:27:03.981 [http-nio-8088-exec-8] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求开始: [获取知识库数据], 入参: , 请求类: WikiController, 请求方法: findWikiList =================================== 
2024-07-22 22:27:03.984 [http-nio-8088-exec-5] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ## HeaderUserId2ContextFilter，用户 ID：1
2024-07-22 22:27:03.984 [http-nio-8088-exec-4] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ## HeaderUserId2ContextFilter，用户 ID：1
2024-07-22 22:27:03.984 [http-nio-8088-exec-4] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 设置 userId 到 ThreadLocal 中， 用户 ID: 1
2024-07-22 22:27:03.984 [http-nio-8088-exec-5] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 设置 userId 到 ThreadLocal 中， 用户 ID: 1
2024-07-22 22:27:03.985 [http-nio-8088-exec-4] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求开始: [前台获取统计信息], 入参: , 请求类: StatisticsController, 请求方法: findInfo =================================== 
2024-07-22 22:27:03.988 [http-nio-8088-exec-5] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求开始: [前台获取分类列表], 入参: {"size":10}, 请求类: CategoryController, 请求方法: findCategoryList =================================== 
2024-07-22 22:27:03.992 [http-nio-8088-exec-10] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ## HeaderUserId2ContextFilter，用户 ID：1
2024-07-22 22:27:03.992 [http-nio-8088-exec-5] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求结束: [前台获取分类列表], 耗时: 4ms, 出参: {"success":true,"message":null,"errorCode":null,"data":[{"id":29,"name":"Java","articlesTotal":6},{"id":31,"name":"SNN","articlesTotal":6},{"id":33,"name":"SpringBoot","articlesTotal":3},{"id":30,"name":"工具","articlesTotal":2},{"id":34,"name":"Redis","articlesTotal":2},{"id":32,"name":"Spring","articlesTotal":1},{"id":35,"name":"RabbitMQ","articlesTotal":1},{"id":36,"name":"MySQL","articlesTotal":1},{"id":37,"name":"MongoDB","articlesTotal":1},{"id":38,"name":"ElasticSearch","articlesTotal":1}]} =================================== 
2024-07-22 22:27:03.992 [http-nio-8088-exec-10] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 设置 userId 到 ThreadLocal 中， 用户 ID: 1
2024-07-22 22:27:03.993 [http-nio-8088-exec-10] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求开始: [前台获取标签列表], 入参: , 请求类: TagController, 请求方法: findTagList =================================== 
2024-07-22 22:27:03.993 [http-nio-8088-exec-5] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 删除 ThreadLocal， userId: 1
2024-07-22 22:27:03.996 [http-nio-8088-exec-4] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求结束: [前台获取统计信息], 耗时: 11ms, 出参: {"success":true,"message":null,"errorCode":null,"data":{"articleTotalCount":28,"categoryTotalCount":15,"tagTotalCount":24,"pvTotalCount":764}} =================================== 
2024-07-22 22:27:03.996 [http-nio-8088-exec-10] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求结束: [前台获取标签列表], 耗时: 3ms, 出参: {"success":true,"message":null,"errorCode":null,"data":[{"id":47,"name":"java","articlesTotal":13},{"id":48,"name":"脉冲神经网络","articlesTotal":6},{"id":49,"name":"snn","articlesTotal":6},{"id":54,"name":"联想记忆模型","articlesTotal":1},{"id":55,"name":"集合","articlesTotal":1},{"id":56,"name":"并发","articlesTotal":1},{"id":57,"name":"RabbitMQ","articlesTotal":2},{"id":58,"name":"spring","articlesTotal":4},{"id":59,"name":"springboot","articlesTotal":4},{"id":60,"name":"mongodb","articlesTotal":2},{"id":61,"name":"nosql","articlesTotal":1},{"id":62,"name":"redis","articlesTotal":2},{"id":63,"name":"mysql","articlesTotal":1},{"id":64,"name":"jvm","articlesTotal":1},{"id":65,"name":"elasticSearch","articlesTotal":1},{"id":66,"name":"SpringMVC","articlesTotal":1},{"id":67,"name":"计算机网络","articlesTotal":1},{"id":68,"name":"操作系统","articlesTotal":1},{"id":69,"name":"设计模式","articlesTotal":1},{"id":70,"name":"SpringCloud","articlesTotal":2},{"id":71,"name":"微服务","articlesTotal":3},{"id":72,"name":"jmm","articlesTotal":1},{"id":73,"name":"高可用","articlesTotal":2},{"id":74,"name":"系统设计","articlesTotal":2}]} =================================== 
2024-07-22 22:27:03.997 [http-nio-8088-exec-10] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 删除 ThreadLocal， userId: 1
2024-07-22 22:27:03.997 [http-nio-8088-exec-4] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 删除 ThreadLocal， userId: 1
2024-07-22 22:27:04.011 [http-nio-8088-exec-8] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求结束: [获取知识库数据], 耗时: 30ms, 出参: {"success":true,"message":null,"errorCode":null,"data":[{"id":6,"cover":"http://110.41.141.141:9000/weblog/fea0e0402a73479ab1603148b4187027.jpg","title":"中间件","summary":"后端开发中间件","isTop":false,"firstArticleId":39},{"id":5,"cover":"http://110.41.141.141:9000/weblog/weblog/ea44696cf3dd408584d04a46452bfbd6.jpg","title":"计算机基础","summary":"计算机基础知识","isTop":false,"firstArticleId":54},{"id":4,"cover":"http://110.41.141.141:9000/weblog/weblog/80061883b8514ae3a557fe8d7db8f6b2.jpg","title":"项目","summary":"项目整理","isTop":false,"firstArticleId":43},{"id":3,"cover":"http://110.41.141.141:9000/weblog/weblog/fb84627b093e4fa98ef9bdf5fbfe8cbc.jpg","title":"系统设计","summary":"系统设计","isTop":false,"firstArticleId":40},{"id":2,"cover":"http://110.41.141.141:9000/weblog/weblog/ca753e837e2344319d9f58a92d25403f.jpg","title":"Java","summary":"Java后端开发","isTop":false,"firstArticleId":33},{"id":1,"cover":"http://110.41.141.141:9000/weblog/weblog/2b484d7d659f4a3aaa9ba74271e55fda.jpg","title":"数据库","summary":"数据库，包括关系型数据库、非关系型数据库以及缓存等","isTop":false,"firstArticleId":47}]} =================================== 
2024-07-22 22:27:04.012 [http-nio-8088-exec-8] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 删除 ThreadLocal， userId: 1
2024-07-22 22:27:05.532 [http-nio-8088-exec-2] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ## HeaderUserId2ContextFilter，用户 ID：1
2024-07-22 22:27:05.532 [http-nio-8088-exec-2] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 设置 userId 到 ThreadLocal 中， 用户 ID: 1
2024-07-22 22:27:05.532 [http-nio-8088-exec-2] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求开始: [前台获取博客详情], 入参: , 请求类: BlogSettingsController, 请求方法: findDetail =================================== 
2024-07-22 22:27:05.536 [http-nio-8088-exec-2] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求结束: [前台获取博客详情], 耗时: 4ms, 出参: {"success":true,"message":null,"errorCode":null,"data":{"logo":"http://110.41.141.141:9000/weblog/weblog/9853f8be13cb4f7fae00e3f5233dd688.png","name":"WebLog","author":"Jacob","introduction":"求知若饥，虚心若愚","avatar":"http://110.41.141.141:9000/weblog/weblog/cf0958d87787449fb05aae4cc84015c6.jpg","githubHomepage":"https://github.com/jdw-art","csdnHomepage":"https://www.csdn.net/?spm=1010.2135.3001.4476","giteeHomepage":"","zhihuHomepage":"https://www.zhihu.com/people/54-10-50-93"}} =================================== 
2024-07-22 22:27:05.538 [http-nio-8088-exec-2] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 删除 ThreadLocal， userId: 1
2024-07-22 22:27:05.543 [http-nio-8088-exec-3] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ## HeaderUserId2ContextFilter，用户 ID：1
2024-07-22 22:27:05.543 [http-nio-8088-exec-3] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 设置 userId 到 ThreadLocal 中， 用户 ID: 1
2024-07-22 22:27:05.544 [http-nio-8088-exec-6] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ## HeaderUserId2ContextFilter，用户 ID：1
2024-07-22 22:27:05.544 [http-nio-8088-exec-1] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ## HeaderUserId2ContextFilter，用户 ID：1
2024-07-22 22:27:05.544 [http-nio-8088-exec-6] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 设置 userId 到 ThreadLocal 中， 用户 ID: 1
2024-07-22 22:27:05.544 [http-nio-8088-exec-1] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 设置 userId 到 ThreadLocal 中， 用户 ID: 1
2024-07-22 22:27:05.545 [http-nio-8088-exec-3] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求开始: [获取知识库目录数据], 入参: {"id":3}, 请求类: WikiController, 请求方法: findWikiCatalogList =================================== 
2024-07-22 22:27:05.545 [http-nio-8088-exec-1] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求开始: [获取知识库文章上下页], 入参: {"id":3,"articleId":40}, 请求类: WikiController, 请求方法: findArticlePreNext =================================== 
2024-07-22 22:27:05.545 [http-nio-8088-exec-6] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求开始: [获取文章详情], 入参: {"articleId":40}, 请求类: ArticleController, 请求方法: findArticleDetail =================================== 
2024-07-22 22:27:05.548 [http-nio-8088-exec-3] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求结束: [获取知识库目录数据], 耗时: 3ms, 出参: {"success":true,"message":null,"errorCode":null,"data":[{"id":132,"articleId":null,"title":"开发框架","level":1,"children":[{"id":133,"articleId":40,"title":"Spring","level":2,"children":null},{"id":134,"articleId":41,"title":"SpringBoot","level":2,"children":null},{"id":135,"articleId":50,"title":"SpringMVC","level":2,"children":null}]},{"id":136,"articleId":null,"title":"分布式","level":1,"children":[{"id":137,"articleId":56,"title":"SpringCloud","level":2,"children":null},{"id":138,"articleId":57,"title":"微服务","level":2,"children":null},{"id":139,"articleId":59,"title":"负载均衡","level":2,"children":null}]},{"id":140,"articleId":null,"title":"系统设计","level":1,"children":[{"id":141,"articleId":55,"title":"DesignPattern","level":2,"children":null}]}]} =================================== 
2024-07-22 22:27:05.549 [http-nio-8088-exec-3] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 删除 ThreadLocal， userId: 1
2024-07-22 22:27:05.553 [http-nio-8088-exec-1] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求结束: [获取知识库文章上下页], 耗时: 8ms, 出参: {"success":true,"message":null,"errorCode":null,"data":{"preArticle":null,"nextArticle":{"articleId":41,"articleTitle":"SpringBoot"}}} =================================== 
2024-07-22 22:27:05.554 [http-nio-8088-exec-1] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 删除 ThreadLocal， userId: 1
2024-07-22 22:27:05.618 [http-nio-8088-exec-6] INFO  c.j.weblog.event.subscriber.ReadArticleSubscriber - ==> threadName: http-nio-8088-exec-6
2024-07-22 22:27:05.618 [http-nio-8088-exec-6] INFO  c.j.weblog.event.subscriber.ReadArticleSubscriber - ==> 文章阅读事件消费成功，articleId: 40
2024-07-22 22:27:05.697 [http-nio-8088-exec-6] INFO  c.j.weblog.event.subscriber.ReadArticleSubscriber - ==> 文章阅读量 +1 操作成功，articleId: 40
2024-07-22 22:27:05.702 [http-nio-8088-exec-6] INFO  c.j.weblog.event.subscriber.ReadArticleSubscriber - ==> 当日文章 PV 访问量 +1 操作成功，date: 2024-07-22
2024-07-22 22:27:05.702 [http-nio-8088-exec-6] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求结束: [获取文章详情], 耗时: 157ms, 出参: {"success":true,"message":null,"errorCode":null,"data":{"title":"Spring","content":"<blockquote>\n<ol>\n<li>什么是 Spring 框架?</li>\n<li>列举一些重要的 Spring 模块？</li>\n<li>谈谈自己对于 Spring IoC 和 AOP 的理解</li>\n<li>Spring Bean 的生命周期说一下</li>\n<li>Spring 中的 bean 的作用域有哪些?</li>\n<li>拦截器和过滤器了解么？</li>\n<li>Spring 动态代理默认用哪一种</li>\n<li>hibernate 和 mybatis 区别</li>\n<li>Spring Boot 和 Spring 的区别</li>\n<li>说出使用 Spring Boot 的主要优点</li>\n<li>什么是 Spring Boot Starter?</li>\n<li>介绍一下<code>@SpringBootApplication</code> 注解</li>\n<li>Spring Boot 的自动配置是如何实现的?</li>\n<li>Spring Boot 支持哪些嵌入式 web 容器？</li>\n</ol>\n</blockquote>\n<h2 id=\"1spring的优点\">1、Spring的优点</h2>\n<ul>\n<li>\n<p>通过控制反转和依赖注入实现<strong>松耦合</strong>。</p>\n</li>\n<li>\n<p>支持<strong>面向切面</strong>的编程，并且把应用业务逻辑和系统服务分开。</p>\n</li>\n<li>\n<p>通过<strong>切面和模板</strong>减少样板式代码。</p>\n</li>\n<li>\n<p><strong>声明式事务</strong>的支持。可以从单调冗余的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。</p>\n</li>\n<li>\n<p>方便<strong>集成各种优秀框架</strong>。内部提供了对各种优秀框架的直接支持（如：Hessian、Quartz、MyBatis等）。</p>\n</li>\n<li>\n<p>方便<strong>程序的测试</strong>。Spring支持Junit4，添加注解便可以测试Spring程序。</p>\n</li>\n</ul>\n<h2 id=\"2restcontroller-vs-controller\"><em>2、@RestController vs @Controller</em></h2>\n<p><strong>@Controller 返回⼀个⻚⾯</strong>：</p>\n<p>单独使用@Controller不加@ResponseBody一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC的应用，对应于前后端不分离的情况</p>\n<p>\n<img src=\"http://110.41.141.141:9000/weblog/weblog/123f2e0ac5894ba9b5f7593305db235d.png\">\n</p>\n<p><strong>@RestController 返回JSON 或 XML 形式数据</strong>：</p>\n<p>但@RestController只返回对象，对象数据直接以JSON或XML的形式写入HTTP响应（Response）中，这种情况属于RestFul Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p>\n<p>\n<img src=\"http://110.41.141.141:9000/weblog/weblog/2d51efa9d2dd4b15b013474693e570c7.png\">\n</p>\n<p><strong>@Controller +@ResponseBody 返回JSON 或 XML 形式数据</strong>：</p>\n<p>如果需要在Spring4之前开发Restful Web服务，需要使用@Controller结合@ResponseBody注解，也就是说@Controller + @ResponseBody = @RestController（Spring4后新加的注解）</p>\n<blockquote>\n<p>@ResponseBody注解的作用是将Controller方法返回的对象通过适当的转换器转换成指定的格式之后，写入到HTTP响应（Response）的body中，通常用来返回JSON或XML数据，返回JSON数据的情况较多</p>\n</blockquote>\n<p>\n<img src=\"http://110.41.141.141:9000/weblog/weblog/c5c1dad248a640ca9d1f4620e0942c71.png\">\n</p>\n<h2 id=\"3spring-ioc--aop\"><em>3、Spring IOC &amp; AOP</em></h2>\n<h3 id=\"31ioc\">3.1、IoC</h3>\n<p>IoC（Inverse of Control:控制反转）就是将对象之间的相互依赖关系交给loC容器来管理，并由loC容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。loC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。在实际项目中一个Service类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个Service，可能要每次都要搞清这个Service所有底层类的构造函数。如果利用loC的话，只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>\n<h3 id=\"32spring-ioc的初始化过程\">3.2、Spring IoC的初始化过程：</h3>\n<p>\n<img src=\"http://110.41.141.141:9000/weblog/weblog/9a0ee6630045403c9a0ea9f5385b2417.png\">\n</p>\n<ul>\n<li>\n<p>从XML中读取配置文件。</p>\n</li>\n<li>\n<p>将bean标签解析成 BeanDefinition，如解析 property 元素， 并注入到 BeanDefinition 实例中。</p>\n</li>\n<li>\n<p>将 BeanDefinition 注册到容器 BeanDefinitionMap 中。</p>\n</li>\n<li>\n<p>BeanFactory 根据 BeanDefinition 的定义信息创建实例和初始化 bean。</p>\n</li>\n</ul>\n<h3 id=\"34aop\">3.4、AOP</h3>\n<p>AOP（Aspect-Oriented Programming：面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任(例如事务处理、日志管理、权限控制等)封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>\n<p>Spring AOP是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy去进行代理了，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理，如下图所示：</p>\n<p>\n<img src=\"http://110.41.141.141:9000/weblog/weblog/7e22847b8a7243f594c5e73792562dc9.png\">\n</p>\n<p>使用AOP之后可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了AOP。</p>\n<blockquote>\n<p>Spring的AOP实现原理其实很简单，就是通过动态代理实现的。如果我们为Spring的某个bean配置了切面，那么Spring在创建这个bean的时候，实际上创建的是这个bean的一个代理对象，我们后续对bean中方法的调用，实际上调用的是代理类重写的代理方法。而Spring的AOP使用了两种动态代理，分别是JDK的动态代理，以及CGLib的动态代理。</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>基于JDK的动态代理：Spring默认使用JDK的动态代理实现AOP，类如果实现了接口，Spring就会使用这种方式实现动态代理。熟悉Java语言的应该会对JDK动态代理有所了解。JDK实现动态代理需要两个组件，首先第一个就是InvocationHandler接口。我们在使用JDK的动态代理时，需要编写一个类，去实现这个接口，然后重写invoke方法，这个方法其实就是我们提供的代理方法。然后JDK动态代理需要使用的第二个组件就是Proxy这个类，我们可以通过这个类的newProxyInstance方法，返回一个代理对象。生成的代理类实现了原来那个类的所有接口，并对接口的方法进行了代理，我们通过代理对象调用这些方法时，底层将通过反射，调用我们实现的invoke方法。</li>\n<li></li>\n<li>基于CGLIB的动态代理：JDK的动态代理存在限制，那就是被代理的类必须是一个实现了接口的类，代理类需要实现相同的接口，代理接口中声明的方法。若需要代理的类没有实现接口，此时JDK的动态代理将没有办法使用，于是Spring会使用CGLib的动态代理来生成代理对象。CGLib直接操作字节码，生成类的子类，重写类的方法完成代理。</li>\n</ul>\n</blockquote>\n<h3 id=\"35spring-aop-和-aspectj-aop-有什么区别\">3.5、Spring AOP 和 AspectJ AOP 有什么区别</h3>\n<ul>\n<li>\n<p>Spring AOP属于运行时增强，而AspectJ是编译时增强。Spring AOP基于代理(Proxying)，而AspectJ基于字节码操作(Bytecode Manipulation)。</p>\n</li>\n<li>\n<p>Spring AOP已经集成了AspectJ ，AspectJ 应该算的上是Java生态系统中最完整的AOP框架了。AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。</p>\n</li>\n<li>\n<p>如果切面比较少，那么两者性能差异不大。但是，当切面太多的话， 最好选择AspectJ ，它比Spring AOP快很多。</p>\n</li>\n</ul>\n<h2 id=\"4spring通知的类型\">4、Spring通知的类型</h2>\n<p>在AOP术语中，切面的工作被称为通知。通知实际上是程序运行时要通过Spring AOP框架来触发的代码段。</p>\n<p>Spring切面可以应用5种类型的通知：</p>\n<ol>\n<li><strong>前置通知</strong>（Before）：在目标方法被调用之前调用通知功能；</li>\n<li><strong>后置通知</strong>（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>\n<li><strong>返回通知</strong>（After-returning ）：在目标方法成功执行之后调用通知；</li>\n<li><strong>异常通知</strong>（After-throwing）：在目标方法抛出异常后调用通知；</li>\n<li><strong>环绕通知</strong>（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的逻辑。</li>\n</ol>\n<h2 id=\"5bean的生命周期\"><em>5、Bean的生命周期</em></h2>\n<blockquote>\n<p>关于Bean的生命周期，Spring容器管理Bean的生命周期，包括实例化、属性设置、初始化、使用和销毁阶段。在初始化和销毁阶段，开发人员可以插入自定义逻辑，以确保Bean的正确配置和资源释放。</p>\n</blockquote>\n<p>\n<img src=\"http://110.41.141.141:9000/weblog/weblog/d9252d261bab4f92ab921bfc9afb7baa.png\">\n</p>\n<p>1.调用bean的构造方法创建Bean</p>\n<p>2.通过反射调用setter方法进行属性的依赖注入</p>\n<p>3.如果Bean实现了<code>BeanNameAware</code>接口，Spring将调用<code>setBeanName</code>()，设置 <code>Bean</code>的name（xml文件中bean标签的id）</p>\n<p>4.如果Bean实现了<code>BeanFactoryAware</code>接口，Spring将调用<code>setBeanFactory()</code>把bean factory设置给Bean</p>\n<p>5.如果存在<code>BeanPostProcessor</code>，Spring将调用它们的<code>postProcessBeforeInitialization</code>（预初始化）方法，在Bean初始化前对其进行处理</p>\n<p>6.如果Bean实现了<code>InitializingBean</code>接口，Spring将调用它的<code>afterPropertiesSet</code>方法，然后调用xml定义的 init-method 方法，两个方法作用类似，都是在初始化 bean 的时候执行</p>\n<p>7.如果存在<code>BeanPostProcessor</code>，Spring将调用它们的<code>postProcessAfterInitialization</code>（后初始化）方法，在Bean初始化后对其进行处理</p>\n<p>8.Bean初始化完成，供应用使用，这里分两种情况：</p>\n<p>8.1 如果Bean为单例的话，那么容器会返回Bean给用户，并存入缓存池。如果Bean实现了<code>DisposableBean</code>接口，Spring将调用它的<code>destory</code>方法，然后调用在xml中定义的 <code>destory-method</code>方法，这两个方法作用类似，都是在Bean实例销毁前执行。</p>\n<p>8.2 如果Bean是多例的话，容器将Bean返回给用户，剩下的生命周期由用户控制。</p>\n<pre><code class=\"language-java\">public interface BeanPostProcessor {\n\t@Nullable\n\tdefault Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}\n\t@Nullable\n\tdefault Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}\n}\npublic interface InitializingBean {\n\tvoid afterPropertiesSet() throws Exception;\n}\n</code></pre>\n<ol>\n<li>调用构造方法，创建对应的Bean类。此时Bean类中的属性都是空的。</li>\n<li>将Bean所依赖的一些数据，如待注入的容器等，填充到Bean对象中。</li>\n<li>调用bean内的一些方法，如启动数据库链接等。同时将Bean填充到容器中存储起来，以方便应用程序获取使用。</li>\n<li>如果当前不再使用该Bean对象，则调用销毁方法，将当前Bean销毁。</li>\n</ol>\n<p>对应着bean的生命周期：</p>\n<ul>\n<li><strong>实例化 Instantiation</strong></li>\n<li><strong>属性赋值 Populate</strong></li>\n<li><strong>初始化 Initialization</strong>（这里需要注意，初始化主要负责执行一些Bean的启动、链接方法，如连接数据库等。）</li>\n<li><strong>销毁 Destruction</strong></li>\n</ul>\n<h2 id=\"6beanfactory和factorybean的区别\">6、BeanFactory和FactoryBean的区别？</h2>\n<p><strong>BeanFactory</strong>：管理Bean的容器，Spring中生成的Bean都是由这个接口的实现来管理的。</p>\n<p><strong>FactoryBean</strong>：通常是用来创建比较复杂的bean，一般的bean 直接用xml配置即可，但如果一个bean的创建过程中涉及到很多其他的bean 和复杂的逻辑，直接用xml配置比较麻烦，这时可以考虑用FactoryBean，可以隐藏实例化复杂Bean的细节。</p>\n<p>当配置文件中bean标签的class属性配置的实现类是FactoryBean时，通过 getBean()方法返回的不是FactoryBean本身，而是调用FactoryBean#getObject()方法所返回的对象，相当于FactoryBean#getObject()代理了getBean()方法。如果想得到FactoryBean必须使用 '&amp;' + beanName 的方式获取。</p>\n<p>Mybatis 提供了 <code>SqlSessionFactoryBean</code>，可以简化 <code>SqlSessionFactory</code>的配置：</p>\n<pre><code class=\"language-java\">public class SqlSessionFactoryBean implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ApplicationEvent&gt; {\n  @Override\n  public void afterPropertiesSet() throws Exception {\n    notNull(dataSource, &quot;Property 'dataSource' is required&quot;);\n    notNull(sqlSessionFactoryBuilder, &quot;Property 'sqlSessionFactoryBuilder' is required&quot;);\n    state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null),\n              &quot;Property 'configuration' and 'configLocation' can not specified with together&quot;);\n    this.sqlSessionFactory = buildSqlSessionFactory();\n  }\n\n  protected SqlSessionFactory buildSqlSessionFactory() throws IOException {\n\t//复杂逻辑\n  }\n    \n  @Override\n  public SqlSessionFactory getObject() throws Exception {\n    if (this.sqlSessionFactory == null) {\n      afterPropertiesSet();\n    }\n    return this.sqlSessionFactory;\n  }\n}\n</code></pre>\n<p>在 xml 配置 SqlSessionFactoryBean：</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;tradeSqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\n    &lt;property name=&quot;dataSource&quot; ref=&quot;trade&quot; /&gt;\n    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapper/trade/*Mapper.xml&quot; /&gt;\n    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt;\n    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.bytebeats.mybatis3.domain.trade&quot; /&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>Spring 将会在应用启动时创建 <code>SqlSessionFactory</code>，并使用 <code>sqlSessionFactory</code> 这个名字存储起来。</p>\n<h2 id=\"7beanfactory和applicationcontext有什么区别\">7、BeanFactory和ApplicationContext有什么区别？</h2>\n<p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>\n<p>两者区别如下：</p>\n<p>1、功能上的区别。BeanFactory是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>\n<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能，如继承MessageSource、支持国际化、统一的资源文件访问方式、同时加载多个配置文件等功能。</p>\n<p>2、加载方式的区别。BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>\n<p>而ApplicationContext是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单例Bean，那么在需要的时候，不需要等待创建bean，因为它们已经创建好了。</p>\n<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>\n<p>3、创建方式的区别。BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>\n<p>4、注册方式的区别。BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>\n<h2 id=\"8bean注入容器有哪些方式\"><em>8、Bean注入容器有哪些方式？</em></h2>\n<p>1、<strong>@Configuration + @Bean</strong></p>\n<p>@Configuration用来声明一个配置类，然后使用 @Bean 注解，用于声明一个bean，将其加入到Spring容器中。</p>\n<pre><code class=\"language-java\">@Configuration\npublic class MyConfiguration {\n    @Bean\n    public Person person() {\n        Person person = new Person();\n        person.setName(&quot;大彬&quot;);\n        return person;\n    }\n}\n</code></pre>\n<p>2、<strong>通过包扫描特定注解的方式</strong></p>\n<p>@ComponentScan放置在我们的配置类上，然后可以指定一个路径，进行扫描带有特定注解的bean，然后加至容器中。</p>\n<p>特定注解包括@Controller、@Service、@Repository、@Component</p>\n<pre><code class=\"language-java\">@Component\npublic class Person {\n    //...\n}\n \n@ComponentScan(basePackages = &quot;com.dabin.test.*&quot;)\npublic class Demo1 {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(Demo1.class);\n        Person bean = applicationContext.getBean(Person.class);\n        System.out.println(bean);\n    }\n}\n</code></pre>\n<p>3、<strong>@Import注解导入</strong></p>\n<p>@Import注解平时开发用的不多，但是也是非常重要的，在进行Spring扩展时经常会用到，它经常搭配自定义注解进行使用，然后往容器中导入一个配置文件。</p>\n<pre><code class=\"language-java\">@ComponentScan\n/*把用到的资源导入到当前容器中*/\n@Import({Person.class})\npublic class App {\n    public static void main(String[] args) throws Exception {\n        ConfigurableApplicationContext context = SpringApplication.run(App.class, args);\n        System.out.println(context.getBean(Person.class));\n        context.close();\n    }\n}\n</code></pre>\n<p>4、<strong>实现BeanDefinitionRegistryPostProcessor进行后置处理。</strong></p>\n<p>在Spring容器启动的时候会执行 BeanDefinitionRegistryPostProcessor 的 postProcessBeanDefinitionRegistry 方法，就是等beanDefinition加载完毕之后，对beanDefinition进行后置处理，可以在此进行调整IOC容器中的beanDefinition，从而干扰到后面进行初始化bean。</p>\n<p>在下面的代码中，我们手动向beanDefinitionRegistry中注册了person的BeanDefinition。最终成功将person加入到applicationContext中。</p>\n<pre><code class=\"language-java\">public class Demo1 {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();\n        MyBeanDefinitionRegistryPostProcessor beanDefinitionRegistryPostProcessor = new MyBeanDefinitionRegistryPostProcessor();\n        applicationContext.addBeanFactoryPostProcessor(beanDefinitionRegistryPostProcessor);\n        applicationContext.refresh();\n        Person bean = applicationContext.getBean(Person.class);\n        System.out.println(bean);\n    }\n}\n \nclass MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(Person.class).getBeanDefinition();\n        registry.registerBeanDefinition(&quot;person&quot;, beanDefinition);\n    }\n    \n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n    }\n}\n</code></pre>\n<p>5、<strong>使用FactoryBean接口</strong></p>\n<p>如下图代码，使用@Configuration + @Bean的方式将 PersonFactoryBean 加入到容器中，这里没有向容器中直接注入 Person，而是注入 PersonFactoryBean，然后从容器中拿Person这个类型的bean。</p>\n<pre><code class=\"language-java\">@Configuration\npublic class Demo1 {\n    @Bean\n    public PersonFactoryBean personFactoryBean() {\n        return new PersonFactoryBean();\n    }\n \n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(Demo1.class);\n        Person bean = applicationContext.getBean(Person.class);\n        System.out.println(bean);\n    }\n}\n \nclass PersonFactoryBean implements FactoryBean&lt;Person&gt; {\n    @Override\n    public Person getObject() throws Exception {\n        return new Person();\n    }\n\n    @Override\n    public Class&lt;?&gt; getObjectType() {\n        return Person.class;\n    }\n}\n</code></pre>\n<h2 id=\"9bean的作用域\"><em>9、Bean的作用域</em></h2>\n<p>1、<strong>singleton</strong>：单例，Spring中的bean默认都是单例的。</p>\n<p>2、<strong>prototype</strong>：每次请求都会创建一个新的bean实例。</p>\n<p>3、<strong>request</strong>：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</p>\n<p>4、<strong>session</strong>：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效。</p>\n<p>5、<strong>global-session</strong>：全局session作用域。</p>\n<table>\n<thead>\n<tr>\n<th>作用域</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>singleton（默认）</td>\n<td>将单个 bean 定义限定为每个 Spring IoC 容器的单个对象实例。</td>\n</tr>\n<tr>\n<td>property</td>\n<td>将单个 bean 定义限定为任意数量的对象实例</td>\n</tr>\n<tr>\n<td>request</td>\n<td>每次用户请求时，只生成一个Bean对象。</td>\n</tr>\n<tr>\n<td>session</td>\n<td>每次Http会话建立到终止时，只能够生成一个对应的Bean实例。</td>\n</tr>\n<tr>\n<td>application</td>\n<td>每次应用启动到终止，只维持一个对应的Bean实例对象。</td>\n</tr>\n<tr>\n<td>websocket</td>\n<td>每次webSocket从建立链接到断开链接，只存在一个对应的Bean实例对象</td>\n</tr>\n</tbody>\n</table>\n<p>从含义的解释上来看，作用域主要是解决Bean的作用范围的。以singleton和property来说，singleton在创建之后，springboot会保证整个上下文环境中都只存在一个该类型的bean。而如果是property情况，那么每次springboot发生加载的时候，都会新创建一个bean进行注入。</p>\n<p>相似的，request、session则是在每次用户请求、每次会话建立都新创建bean进行注入。通过指定作用域，我们就可以判断出当前这个Bean对象的大致生命周期和作用范围。</p>\n<h2 id=\"10spring自动装配的方式有哪些\">10、Spring自动装配的方式有哪些？</h2>\n<ul>\n<li><strong>基于xml文件的自动装配</strong>：byType(类型），byName(名称)， constructor(根据构造函数）</li>\n<li><strong>基于注解的自动装配</strong>：@Autowired，@Resource，@Value</li>\n</ul>\n<p>Spring的自动装配有三种模式：<strong>byType</strong>(根据类型)，<strong>byName</strong>(根据名称)、<strong>constructor</strong>(根据构造函数)。</p>\n<p><strong>byType</strong></p>\n<p>找到与依赖类型相同的bean注入到另外的bean中，这个过程需要借助setter注入来完成，因此必须存在set方法，否则注入失败。</p>\n<p>当xml文件中存在多个相同类型名称不同的实例Bean时，Spring容器依赖注入仍然会失败，因为存在多种适合的选项，Spring容器无法知道该注入那种，此时我们需要为Spring容器提供帮助，指定注入那个Bean实例。可以通过<code>＜bean＞</code>标签的autowire-candidate设置为false来过滤那些不需要注入的实例Bean</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;userDao&quot;  class=&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot; /&gt;\n\n&lt;!-- autowire-candidate=&quot;false&quot; 过滤该类型 --&gt;\n&lt;bean id=&quot;userDao2&quot; autowire-candidate=&quot;false&quot; class=&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot; /&gt;\n\n&lt;!-- byType 根据类型自动装配userDao--&gt;\n&lt;bean id=&quot;userService&quot; autowire=&quot;byType&quot; class=&quot;com.zejian.spring.springIoc.service.impl.UserServiceImpl&quot; /&gt;\n</code></pre>\n<p><strong>byName</strong></p>\n<p>将属性名与bean名称进行匹配，如果找到则注入依赖bean。</p>\n<pre><code class=\"language-xml\">&lt;bean id=&quot;userDao&quot;  class=&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot; /&gt;\n&lt;bean id=&quot;userDao2&quot; class=&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot; /&gt;\n\n&lt;!-- byName 根据名称自动装配，找到UserServiceImpl名为 userDao属性并注入--&gt;\n&lt;bean id=&quot;userService&quot; autowire=&quot;byName&quot; class=&quot;com.zejian.spring.springIoc.service.impl.UserServiceImpl&quot; /&gt;\n</code></pre>\n<p><strong>constructor</strong></p>\n<p>存在单个实例则优先按类型进行参数匹配（无论名称是否匹配），当存在多个类型相同实例时，按名称优先匹配，如果没有找到对应名称，则注入失败。</p>\n<h2 id=\"11autowired和resource的区别\">11、@Autowired和@Resource的区别？</h2>\n<p>Autowire是spring的注解。默认情况下@Autowired是按类型匹配的(byType)。如果需要按名称(byName)匹配的话，可以使用@Qualifier注解与@Autowired结合。@Autowired 可以传递一个<code>required=false</code>的属性，false指明当userDao实例存在就注入不存就忽略，如果为true，就必须注入，若userDao实例不存在，就抛出异常。</p>\n<pre><code class=\"language-java\">public class UserServiceImpl implements UserService {\n    //标注成员变量\n    @Autowired\n    @Qualifier(&quot;userDao1&quot;)\n    private UserDao userDao;   \n }\n</code></pre>\n<p>Resource是j2ee的注解，默认按 byName模式自动注入。@Resource有两个中重要的属性：name和type。name属性指定bean的名字，type属性则指定bean的类型。因此使用name属性，则按byName模式的自动注入策略，如果使用type属性，则按 byType模式自动注入策略。倘若既不指定name也不指定type属性，Spring容器将通过反射技术默认按byName模式注入。</p>\n<pre><code class=\"language-java\">@Resource(name=&quot;userDao&quot;)\nprivate UserDao  userDao;//用于成员变量\n\n//也可以用于set方法标注\n@Resource(name=&quot;userDao&quot;)\npublic void setUserDao(UserDao userDao) {\n   this.userDao= userDao;\n}\n</code></pre>\n<p>上述两种自动装配的依赖注入并不适合简单值类型，如int、boolean、long、String以及Enum等，对于这些类型，Spring容器也提供了@Value注入的方式。</p>\n<p>@Value和@Autowired、@Resource类似，也是用来对属性进行注入的，只不过@Value是用来从Properties文件中来获取值的，并且@Value可以解析SpEL(Spring表达式)。</p>\n<p>比如，jdbc.properties文件如下：</p>\n<pre><code class=\"language-properties\">jdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://127.0.0.1:3306/test?characterEncoding=UTF-8&amp;allowMultiQueries=true\njdbc.username=root\njdbc.password=root\n</code></pre>\n<p>利用注解@Value获取jdbc.url和jdbc.username的值，实现如下：</p>\n<pre><code class=\"language-java\">public class UserServiceImpl implements UserService {\n    //占位符方式\n    @Value(&quot;${jdbc.url}&quot;)\n    private String url;\n    //SpEL表达方式，其中代表xml配置文件中的id值configProperties\n    @Value(&quot;#{configProperties['jdbc.username']}&quot;)\n    private String userName;\n\n}\n</code></pre>\n<h2 id=\"12qualifier-注解有什么作用\">12、@Qualifier 注解有什么作用</h2>\n<p>当需要创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，可以使用<code>@Qualifier</code> 注解和 <code>@Autowired</code> 通过指定应该装配哪个 bean 来消除歧义。</p>\n<h2 id=\"13bean和component有什么区别\">13、@Bean和@Component有什么区别？</h2>\n<p>都是使用注解定义 Bean。@Bean 是使用 Java 代码装配 Bean，@Component 是自动装配 Bean。</p>\n<p><strong>@Component 注解用在类上</strong>，表明一个类会作为组件类，并告知Spring要为这个类创建bean，每个类对应一个 Bean。</p>\n<p><strong>@Bean 注解用在方法上</strong>，表示这个方法会返回一个 Bean。@Bean 需要在配置类中使用，即类上需要加上@Configuration注解。</p>\n<pre><code class=\"language-java\">@Component\npublic class Student {\n    private String name = &quot;lkm&quot;;\n \n    public String getName() {\n        return name;\n    }\n}\n\n@Configuration\npublic class WebSocketConfig {\n    @Bean\n    public Student student(){\n        return new Student();\n    }\n}\n</code></pre>\n<p>@Bean 注解更加灵活。当需要将第三方类装配到 Spring 容器中，因为没办法源代码上添加@Component注解，只能使用@Bean 注解的方式，当然也可以使用 xml 的方式。</p>\n<h2 id=\"14componentcontrollerrepositor和service-的区别\"><em>14、@Component、@Controller、@Repositor和@Service 的区别？</em></h2>\n<p>@Component：最普通的组件，可以被注入到spring容器进行管理。</p>\n<p>@Controller：将类标记为 Spring Web MVC 控制器。</p>\n<p>@Service：将类标记为业务层组件。</p>\n<p>@Repository：将类标记为数据访问组件，即DAO组件。</p>\n<h2 id=\"15spring-事务实现方式有哪些\">15、Spring 事务实现方式有哪些？</h2>\n<p>事务就是一系列的操作原子执行。Spring事务机制主要包括声明式事务和编程式事务。</p>\n<ul>\n<li><strong>编程式事务</strong>：通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</li>\n<li><strong>声明式事务</strong>：将事务管理代码从业务方法中分离出来，通过aop进行封装。Spring声明式事务使得我们不需要去处理获得连接、关闭连接、事务提交和回滚等这些操作。使用 <code>@Transactional</code> 注解开启声明式事务。</li>\n</ul>\n<p><code>@Transactional</code>相关属性如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">value</td>\n<td>String</td>\n<td>可选的限定描述符，指定使用的事务管理器</td>\n</tr>\n<tr>\n<td align=\"left\">propagation</td>\n<td>enum: Propagation</td>\n<td>可选的事务传播行为设置</td>\n</tr>\n<tr>\n<td align=\"left\">isolation</td>\n<td>enum: Isolation</td>\n<td>可选的事务隔离级别设置</td>\n</tr>\n<tr>\n<td align=\"left\">readOnly</td>\n<td>boolean</td>\n<td>读写或只读事务，默认读写</td>\n</tr>\n<tr>\n<td align=\"left\">timeout</td>\n<td>int (in seconds granularity)</td>\n<td>事务超时时间设置</td>\n</tr>\n<tr>\n<td align=\"left\">rollbackFor</td>\n<td>Class对象数组，必须继承自Throwable</td>\n<td>导致事务回滚的异常类数组</td>\n</tr>\n<tr>\n<td align=\"left\">rollbackForClassName</td>\n<td>类名数组，必须继承自Throwable</td>\n<td>导致事务回滚的异常类名字数组</td>\n</tr>\n<tr>\n<td align=\"left\">noRollbackFor</td>\n<td>Class对象数组，必须继承自Throwable</td>\n<td>不会导致事务回滚的异常类数组</td>\n</tr>\n<tr>\n<td align=\"left\">noRollbackForClassName</td>\n<td>类名数组，必须继承自Throwable</td>\n<td>不会导致事务回滚的异常类名字数组</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"16有哪些事务传播行为\"><em>16、有哪些事务传播行为？</em></h2>\n<p>Spring 事务的传播机制说的是，当多个事务同时存在的时候——一般指的是多个事务方法相互调用时，Spring 如何处理这些事务的行为。事务传播机制是使用简单的 ThreadLocal 实现的，所以，如果调用的方法是在新线程调用的，事务传播实际上是会失效的。</p>\n<p>在TransactionDefinition接口中定义了七个事务传播行为：</p>\n<ol>\n<li><code>PROPAGATION_REQUIRED</code>如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。如果嵌套调用的两个方法都加了事务注解，并且运行在相同线程中，则这两个方法使用相同的事务中。如果运行在不同线程中，则会开启新的事务。</li>\n<li><code>PROPAGATION_SUPPORTS</code> 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。</li>\n<li><code>PROPAGATION_MANDATORY</code> 如果已经存在一个事务，支持当前事务。如果不存在事务，则抛出异常<code>IllegalTransactionStateException</code>。</li>\n<li><code>PROPAGATION_REQUIRES_NEW</code> 总是开启一个新的事务。需要使用JtaTransactionManager作为事务管理器。</li>\n<li><code>PROPAGATION_NOT_SUPPORTED</code> 总是非事务地执行，并挂起任何存在的事务。需要使用JtaTransactionManager作为事务管理器。</li>\n<li><code>PROPAGATION_NEVER</code> 总是非事务地执行，如果存在一个活动事务，则抛出异常。</li>\n<li><code>PROPAGATION_NESTED</code> 如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务, 则按PROPAGATION_REQUIRED 属性执行。</li>\n</ol>\n<p><strong>PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:</strong></p>\n<p>使用<code>PROPAGATION_REQUIRES_NEW</code>时，内层事务与外层事务是两个独立的事务。一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。</p>\n<p>使用<code>PROPAGATION_NESTED</code>时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。</p>\n<h2 id=\"17spring事务在什么情况下会失效\">17、Spring事务在什么情况下会失效？</h2>\n<p><strong>1.访问权限问题</strong></p>\n<p>java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。</p>\n<p>如果事务方法的访问权限不是定义成public，这样会导致事务失效，因为spring要求被代理方法必须是<code>public</code>的。</p>\n<p>翻开源码，可以看到，在<code>AbstractFallbackTransactionAttributeSource</code>类的<code>computeTransactionAttribute</code>方法中有个判断，如果目标方法不是public，则返回null，即不支持事务。</p>\n<pre><code class=\"language-java\">protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) {\n    // Don't allow no-public methods as required.\n    if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {\n      return null;\n    }\n\t...\n}\n</code></pre>\n<p><strong>2. 方法用final修饰</strong></p>\n<p>如果事务方法用final修饰，将会导致事务失效。因为spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。</p>\n<p>但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。</p>\n<blockquote>\n<p>同理，如果某个方法是static的，同样无法通过动态代理，变成事务方法。</p>\n</blockquote>\n<p><strong>3.对象没有被spring管理</strong></p>\n<p>使用spring事务的前提是：对象要被spring管理，需要创建bean实例。如果类没有加@Controller、@Service、@Component、@Repository等注解，即该类没有交给spring去管理，那么它的方法也不会生成事务。</p>\n<p><strong>4.表不支持事务</strong></p>\n<p>如果MySQL使用的存储引擎是myisam，这样的话是不支持事务的。因为myisam存储引擎不支持事务。</p>\n<p><strong>5.方法内部调用</strong></p>\n<p>如下代码所示，update方法上面没有加 <code>@Transactional</code> 注解，调用有 <code>@Transactional</code> 注解的 updateOrder 方法，updateOrder 方法上的事务会失效。</p>\n<p>因为发生了自身调用，调用该类自己的方法，而没有经过 Spring 的代理类，只有在外部调用事务才会生效。</p>\n<pre><code class=\"language-java\">@Service\npublic class OrderServiceImpl implements OrderService {\n\n    public void update(Order order) {\n        this.updateOrder(order);\n    }\n\n    @Transactional\n    public void updateOrder(Order order) {\n        // update order\n    }\n}\n</code></pre>\n<p>解决方法：</p>\n<p>1、再声明一个service，将内部调用改为外部调用</p>\n<p>2、使用编程式事务</p>\n<p>3、使用AopContext.currentProxy()获取代理对象</p>\n<pre><code class=\"language-java\">@Servcie\npublic class OrderServiceImpl implements OrderService {\n    \n   public void update(Order order) {\n        ((OrderService)AopContext.currentProxy()).updateOrder(order);\n   }\n\n    @Transactional\n    public void updateOrder(Order order) {\n        // update order\n    }\n }\n</code></pre>\n<p><strong>6.未开启事务</strong></p>\n<p>如果是spring项目，则需要在配置文件中手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。</p>\n<p>如果是springboot项目，那么不需要手动配置。因为springboot已经在<code>DataSourceTransactionManagerAutoConfiguration</code>类中帮我们开启了事务。</p>\n<p><strong>7.吞了异常</strong></p>\n<p>有时候事务不会回滚，有可能是在代码中手动catch了异常。因为开发者自己捕获了异常，又没有手动抛出，把异常吞掉了，这种情况下spring事务不会回滚。</p>\n<p>如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。</p>\n<h2 id=\"18spring怎么解决循环依赖的问题\">18、Spring怎么解决循环依赖的问题？</h2>\n<p>循环依赖指的是两个类中的属性相互依赖对方：例如 A 类中有 B 属性，B 类中有 A属性，从而形成了一个依赖闭环，如下图。</p>\n<p>\n<img src=\"http://110.41.141.141:9000/weblog/weblog/ea6f71bf2d19468b85a0b3f7d6c63b6b.png\">\n</p>\n<p>循环依赖问题在Spring中主要有三种情况：</p>\n<ul>\n<li>第一种：通过构造方法进行依赖注入时产生的循环依赖问题。</li>\n<li>第二种：通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。</li>\n<li>第三种：通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。</li>\n</ul>\n<p>只有【第三种方式】的循环依赖问题被 Spring 解决了，其他两种方式在遇到循环依赖问题时，Spring都会产生异常。</p>\n<p>Spring 解决单例模式下的setter循环依赖问题的主要方式是通过三级缓存解决循环依赖。三级缓存指的是 Spring 在创建 Bean 的过程中，通过三级缓存来缓存正在创建的 Bean，以及已经创建完成的 Bean 实例。具体步骤如下：</p>\n<ul>\n<li><strong>实例化 Bean</strong>：Spring 在实例化 Bean 时，会先创建一个空的 Bean 对象，并将其放入一级缓存中。</li>\n<li><strong>属性赋值</strong>：Spring 开始对 Bean 进行属性赋值，如果发现循环依赖，会将当前 Bean 对象提前暴露给后续需要依赖的 Bean（通过提前暴露的方式解决循环依赖）。</li>\n<li><strong>初始化 Bean</strong>：完成属性赋值后，Spring 将 Bean 进行初始化，并将其放入二级缓存中。</li>\n<li><strong>注入依赖</strong>：Spring 继续对 Bean 进行依赖注入，如果发现循环依赖，会从二级缓存中获取已经完成初始化的 Bean 实例。</li>\n</ul>\n<p>通过三级缓存的机制，Spring 能够在处理循环依赖时，确保及时暴露正在创建的 Bean 对象，并能够正确地注入已经初始化的 Bean 实例，从而解决循环依赖问题，保证应用程序的正常运行。</p>\n<h2 id=\"19spring启动过程\"><em>19、Spring启动过程</em></h2>\n<ol>\n<li>读取web.xml文件。</li>\n<li>创建 ServletContext，为 ioc 容器提供宿主环境。</li>\n<li>触发容器初始化事件，调用 contextLoaderListener.contextInitialized()方法，在这个方法会初始化一个应用上下文WebApplicationContext，即 Spring 的 ioc 容器。ioc 容器初始化完成之后，会被存储到 ServletContext 中。</li>\n<li>初始化web.xml中配置的Servlet。如DispatcherServlet，用于匹配、处理每个servlet请求。</li>\n</ol>\n<h2 id=\"20spring-的单例-bean-是否有并发安全问题\">20、Spring 的单例 Bean 是否有并发安全问题？</h2>\n<p>当多个用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求对应的业务逻辑，如果业务逻辑有对单例状态的修改（体现为此单例的成员属性），则必须考虑线程安全问题。</p>\n<p><strong>无状态bean和有状态bean</strong></p>\n<ul>\n<li>有实例变量的bean，可以保存数据，是非线程安全的。</li>\n<li>没有实例变量的bean，不能保存数据，是线程安全的。</li>\n</ul>\n<p>在Spring中无状态的Bean适合用单例模式，这样可以共享实例提高性能。有状态的Bean在多线程环境下不安全，一般用<code>Prototype</code>模式或者使用<code>ThreadLocal</code>解决线程安全问题。</p>\n<h2 id=\"21spring-bean如何保证并发安全\">21、Spring Bean如何保证并发安全？</h2>\n<p>Spring的Bean默认都是单例的，某些情况下，单例是并发不安全的。</p>\n<p>以 <code>Controller</code> 举例，假如我们在 <code>Controller</code> 中定义了成员变量。当多个请求来临，进入的都是同一个单例的 <code>Controller</code> 对象，并对此成员变量的值进行修改操作，因此会互相影响，会有并发安全的问题。</p>\n<p>应该怎么解决呢？</p>\n<p>为了让多个HTTP请求之间不互相影响，可以采取以下措施：</p>\n<p><strong>1、单例变原型</strong></p>\n<p>对 web 项目，可以 <code>Controller</code> 类上加注解 @<code>Scope(&quot;prototype&quot;)</code> 或 <code>@Scope(&quot;request&quot;)</code>，对非 web 项目，在 <code>Component</code> 类上添加注解 <code>@Scope(&quot;prototype&quot;)</code> 。</p>\n<p>这种方式实现起来非常简单，但是很大程度上增大了 Bean 创建实例化销毁的服务器资源开销。</p>\n<p><strong>2、尽量避免使用成员变量</strong></p>\n<p>在业务允许的条件下，可以将成员变量替换为方法中的局部变量。这种方式个人认为是最恰当的。</p>\n<p><strong>3、使用并发安全的类</strong></p>\n<p>如果非要在单例Bean中使用成员变量，可以考虑使用并发安全的容器，如 <code>ConcurrentHashMap</code>、<code>ConcurrentHashSet</code> 等等，将我们的成员变量包装到这些并发安全的容器中进行管理即可。</p>\n<p><strong>4、分布式或微服务的并发安全</strong></p>\n<p>如果还要进一步考虑到微服务或分布式服务的影响，方式3便不合适了。这种情况下可以借助于可以共享某些信息的分布式缓存中间件，如Redis等。这样即可保证同一种服务的不同服务实例都拥有同一份共享信息了。</p>\n<h2 id=\"22async注解的原理\">22、@Async注解的原理</h2>\n<p>当我们调用第三方接口或者方法的时候，我们不需要等待方法返回才去执行其它逻辑，这时如果响应时间过长，就会极大的影响程序的执行效率。所以这时就需要使用异步方法来并行执行我们的逻辑。在springboot中可以使用@Async注解实现异步操作。</p>\n<p>使用@Async注解实现异步操作的步骤：</p>\n<p>1.首先在启动类上添加 @EnableAsync 注解。</p>\n<pre><code class=\"language-java\">@Configuration\n@EnableAsync\npublic class App {\n    public static void main(String[] args) {\n         ApplicationContext ctx = new  \n             AnnotationConfigApplicationContext(App.class);\n        MyAsync service = ctx.getBean(MyAsync.class);\n        System.out.println(service.getClass());\n        service.async1();\n        System.out.println(&quot;main thread finish...&quot;);\n    }\n}\n</code></pre>\n<p>2.在对应的方法上添加@Async注解。</p>\n<pre><code class=\"language-java\">@Component\npublic class MyAsync {\n    @Async\n    public void asyncTest() {\n        try {\n            TimeUnit.SECONDS.sleep(20);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(&quot;asyncTest...&quot;);\n    }\n}\n</code></pre>\n<p>运行代码，控制台输出：</p>\n<pre><code class=\"language-java\">main thread finish...\nasyncTest...\n</code></pre>\n<p>证明asyncTest方法异步执行了。</p>\n<p>原理：</p>\n<p>我们在主启动类上贴了一个@EnableAsync注解，才能使用@Async生效。@EnableAsync的作用是通过@import导入了AsyncConfigurationSelector。在AsyncConfigurationSelector的selectImports方法将ProxyAsyncConfiguration定义为Bean注入容器。在ProxyAsyncConfiguration中通过@Bean的方式注入AsyncAnnotationBeanPostProcessor类。</p>\n<p>\n<img src=\"http://110.41.141.141:9000/weblog/weblog/35e69c8c830345b7ad0aaa16161d6c76.png\">\n</p>\n<p>代码如下：</p>\n<pre><code class=\"language-java\">@Import(AsyncConfigurationSelector.class)\npublic @interface EnableAsync {\n}\n\npublic class AsyncConfigurationSelector extends AdviceModeImportSelector&lt;EnableAsync&gt; {\n\tpublic String[] selectImports(AdviceMode adviceMode) {\n\t\tswitch (adviceMode) {\n\t\t\tcase PROXY:\n\t\t\t\treturn new String[] { ProxyAsyncConfiguration.class.getName() };\n\t\t\t//...\n\t\t}\n\t}\n}\n\npublic class ProxyAsyncConfiguration extends AbstractAsyncConfiguration {\n    @Bean(name = TaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME)\n    public AsyncAnnotationBeanPostProcessor asyncAdvisor() {\n        //创建postProcessor\n        AsyncAnnotationBeanPostProcessor bpp = new AsyncAnnotationBeanPostProcessor();\n        //...\n    }\n}\n</code></pre>\n<p>AsyncAnnotationBeanPostProcessor往往期创建了一个增强器AsyncAnnotationAdvisor。在AsyncAnnotationAdvisor的buildAdvice方法中，创建了AnnotationAsyncExecutionInterceptor。</p>\n<pre><code class=\"language-java\">public class AsyncAnnotationBeanPostProcessor extends AbstractBeanFactoryAwareAdvisingPostProcessor {\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) {\n        super.setBeanFactory(beanFactory);\n        //创建一个增强器\n        AsyncAnnotationAdvisor advisor = new AsyncAnnotationAdvisor(this.executor, this.exceptionHandler);\n        //...\n        advisor.setBeanFactory(beanFactory);\n        this.advisor = advisor;\n    }\n}\n\n\npublic class AsyncAnnotationAdvisor extends AbstractPointcutAdvisor implements BeanFactoryAware {\n    public AsyncAnnotationAdvisor(\n            @Nullable Supplier&lt;Executor&gt; executor, @Nullable Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler) {\n        //增强方法\n        this.advice = buildAdvice(executor, exceptionHandler);\n        this.pointcut = buildPointcut(asyncAnnotationTypes);\n    }\n\n    // 委托给AnnotationAsyncExecutionInterceptor拦截器\n    protected Advice buildAdvice(\n            @Nullable Supplier&lt;Executor&gt; executor, @Nullable Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler) {\n        //拦截器\n        AnnotationAsyncExecutionInterceptor interceptor = new AnnotationAsyncExecutionInterceptor(null);\n        interceptor.configure(executor, exceptionHandler);\n        return interceptor;\n    }\n}\n</code></pre>\n<p>AnnotationAsyncExecutionInterceptor继承自AsyncExecutionInterceptor，间接实现了MethodInterceptor。该拦截器的实现的invoke方法把原来方法的调用提交到新的线程池执行，从而实现了方法的异步。</p>\n<pre><code class=\"language-java\">public class AsyncExecutionInterceptor extends AsyncExecutionAspectSupport implements MethodInterceptor, Ordered {\n    public Object invoke(final MethodInvocation invocation) throws Throwable {\n        //...\n        //构建放到AsyncTaskExecutor执行Callable Task\n        Callable&lt;Object&gt; task = () -&gt; {\n            //...\n        };\n        //提交到新的线程池执行\n        return doSubmit(task, executor, invocation.getMethod().getReturnType());\n    }\n}\n</code></pre>\n<p>由上面分析可以看到，@Async注解其实是通过代理的方式来实现异步调用的。</p>\n<p>那使用@Async有什么要注意的呢？</p>\n<p>1.使用@Aysnc的时候最好配置一个线程池Executor以让线程复用节省资源，或者为SimpleAsyncTaskExecutor设置基于线程池实现的ThreadFactory，在否则会默认使用SimpleAsyncTaskExecutor，该executor会在每次调用时新建一个线程。</p>\n<p>2.调用本类的异步方法是不会起作用的。这种方式绕过了代理而直接调用了方法，@Async注解会失效。</p>\n<h2 id=\"23为什么-spring和idea-都不推荐使用-autowired-注解\">23、为什么 Spring和IDEA 都不推荐使用 @Autowired 注解？</h2>\n<p>idea 在我们经常使用的<code>@Autowired</code> 注解上添加了警告。警告内容是: <code>Field injection is not recommended</code>, 译为: <strong>不推荐使用属性注入</strong>。</p>\n<p>Spring常用的注入方式有：属性注入, 构造方法注入, set 方法注入</p>\n<ul>\n<li>构造器注入：利用构造方法的参数注入依赖</li>\n<li>set方法注入：调用setter的方法注入依赖</li>\n<li>属性注入：在字段上使用@Autowired/Resource注解</li>\n</ul>\n<p>其中，基于属性注入的方式，容易导致Spring 初始化失败。因为在Spring在初始化的时候，可能由于属性在被注入前就引用而导致空指针异常，进而导致容器初始化失败。</p>\n<p>如果可能的话，尽量使用构造器注入。Lombok提供了一个注解<code>@RequiredArgsConstructor</code>, 可以方便我们快速进行构造注入。</p>\n<p>@Autowired是属性注入，而且@Autowired默认是按照类型匹配（ByType），因此有可能会出现两个相同的类型bean，进而导致Spring 装配失败。</p>\n<p>如果要使用属性注入的话，可以使用 <code>@Resource</code> 代替 <code>@Autowired</code> 注解。@Resource默认是按照名称匹配（ByName），如果找不到则是ByType注入。另外，@Autowired是Spring提供的，@Resource是JSR-250提供的，是Java标准，我们使用的IoC容器会去兼容它，这样即使更换容器，也可以正常工作。</p>\n<h2 id=\"24jdk动态代理和cglib的区别\"><em>24、JDK动态代理和cglib的区别</em></h2>\n<ul>\n<li>JDK代理只能对实现接口的类生成代理；CGLib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类。</li>\n<li>JDK代理使用的是反射机制实现aop的动态代理，CGLib代理使用字节码处理框架ASM，通过修改字节码生成子类。所以jdk动态代理的方式创建代理对象效率较高，执行效率较低，CGLib创建效率较低，执行效率高。</li>\n<li>JDK动态代理机制是委托机制，具体说动态实现接口类，在动态生成的实现类里面委托hanlder去调用原始实现类方法，CGLib则使用的继承机制，具体说被代理类和代理类是继承关系，所以代理类是可以赋值给被代理类的，如果被代理类有接口，那么代理类也可以赋值给接口。</li>\n</ul>\n<p>\n<img src=\"http://110.41.141.141:9000/weblog/weblog/dc68b05cc7ba4b9e92dfa99c9c03af77.png\">\n</p>\n<h2 id=\"25spring中用到了哪些设计模式\"><em>25、Spring中用到了哪些设计模式</em></h2>\n<blockquote>\n<p>包括工厂设计模式、代理设计模式、单例设计模式、模板方法模式、观察者模式和适配器模式等。这些设计模式有助于实现松耦合、可维护和可扩展的应用程序。</p>\n</blockquote>\n<ul>\n<li>工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li>\n<li>代理设计模式 : Spring AOP 功能的实现。</li>\n<li>单例设计模式 : Spring 中的 Bean 默认都是单例的。</li>\n<li>模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>\n<li>观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>\n<li>适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</li>\n</ul>\n","createTime":"2024-04-27 15:24:36","categoryId":32,"categoryName":"Spring","readNum":59,"tags":[{"id":47,"name":"java","articlesTotal":null},{"id":58,"name":"spring","articlesTotal":null}],"preArticle":{"articleId":41,"articleTitle":"SpringBoot"},"nextArticle":{"articleId":39,"articleTitle":"RabbitMQ"},"totalWords":9863,"readTime":"约 32 分钟","updateTime":"2024-05-24 14:57:44"}} =================================== 
2024-07-22 22:27:05.757 [http-nio-8088-exec-6] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 删除 ThreadLocal， userId: 1
2024-07-22 22:27:08.838 [http-nio-8088-exec-9] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ## HeaderUserId2ContextFilter，用户 ID：1
2024-07-22 22:27:08.838 [http-nio-8088-exec-5] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ## HeaderUserId2ContextFilter，用户 ID：1
2024-07-22 22:27:08.838 [http-nio-8088-exec-9] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 设置 userId 到 ThreadLocal 中， 用户 ID: 1
2024-07-22 22:27:08.838 [http-nio-8088-exec-7] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ## HeaderUserId2ContextFilter，用户 ID：1
2024-07-22 22:27:08.838 [http-nio-8088-exec-5] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 设置 userId 到 ThreadLocal 中， 用户 ID: 1
2024-07-22 22:27:08.838 [http-nio-8088-exec-7] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 设置 userId 到 ThreadLocal 中， 用户 ID: 1
2024-07-22 22:27:08.838 [http-nio-8088-exec-9] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求开始: [前台获取博客详情], 入参: , 请求类: BlogSettingsController, 请求方法: findDetail =================================== 
2024-07-22 22:27:08.839 [http-nio-8088-exec-5] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求开始: [获取文章详情], 入参: {"articleId":59}, 请求类: ArticleController, 请求方法: findArticleDetail =================================== 
2024-07-22 22:27:08.839 [http-nio-8088-exec-7] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求开始: [获取知识库文章上下页], 入参: {"id":3,"articleId":59}, 请求类: WikiController, 请求方法: findArticlePreNext =================================== 
2024-07-22 22:27:08.840 [http-nio-8088-exec-9] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求结束: [前台获取博客详情], 耗时: 2ms, 出参: {"success":true,"message":null,"errorCode":null,"data":{"logo":"http://110.41.141.141:9000/weblog/weblog/9853f8be13cb4f7fae00e3f5233dd688.png","name":"WebLog","author":"Jacob","introduction":"求知若饥，虚心若愚","avatar":"http://110.41.141.141:9000/weblog/weblog/cf0958d87787449fb05aae4cc84015c6.jpg","githubHomepage":"https://github.com/jdw-art","csdnHomepage":"https://www.csdn.net/?spm=1010.2135.3001.4476","giteeHomepage":"","zhihuHomepage":"https://www.zhihu.com/people/54-10-50-93"}} =================================== 
2024-07-22 22:27:08.841 [http-nio-8088-exec-9] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 删除 ThreadLocal， userId: 1
2024-07-22 22:27:08.845 [http-nio-8088-exec-7] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求结束: [获取知识库文章上下页], 耗时: 6ms, 出参: {"success":true,"message":null,"errorCode":null,"data":{"preArticle":{"articleId":57,"articleTitle":"微服务"},"nextArticle":{"articleId":55,"articleTitle":"DesignPattern"}}} =================================== 
2024-07-22 22:27:08.846 [http-nio-8088-exec-7] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 删除 ThreadLocal， userId: 1
2024-07-22 22:27:08.858 [http-nio-8088-exec-5] INFO  c.j.weblog.event.subscriber.ReadArticleSubscriber - ==> threadName: http-nio-8088-exec-5
2024-07-22 22:27:08.858 [http-nio-8088-exec-5] INFO  c.j.weblog.event.subscriber.ReadArticleSubscriber - ==> 文章阅读事件消费成功，articleId: 59
2024-07-22 22:27:09.501 [http-nio-8088-exec-5] INFO  c.j.weblog.event.subscriber.ReadArticleSubscriber - ==> 文章阅读量 +1 操作成功，articleId: 59
2024-07-22 22:27:09.592 [http-nio-8088-exec-5] INFO  c.j.weblog.event.subscriber.ReadArticleSubscriber - ==> 当日文章 PV 访问量 +1 操作成功，date: 2024-07-22
2024-07-22 22:27:09.593 [http-nio-8088-exec-5] INFO  c.j.w.f.b.o.aspect.ApiOperationLogAspect - ====== 请求结束: [获取文章详情], 耗时: 753ms, 出参: {"success":true,"message":null,"errorCode":null,"data":{"title":"负载均衡","content":"<h2 id=\"1-什么是负载均衡\">1、 什么是负载均衡？</h2>\n<p><strong>什么是负载均衡？</strong></p>\n<p>记得第一次接触 Nginx 是在实验室，那时候在服务器部署网站需要用 Nginx 。Nginx 是一个服务组件，用来反向代理、负载平衡和 HTTP 缓存等。那么这里的 负载均衡 是什么？</p>\n<p>负载均衡（LB，Load Balance），是一种技术解决方案。用来在多个资源（一般是服务器）中分配负载，达到最优化资源使用，避免过载。</p>\n<p>\n<img src=\"http://img.topjavaer.cn/img/负载均衡1.jpg\">\n</p>\n<p>资源，相当于每个服务实例的执行操作单元，负载均衡就是将大量的数据处理操作分摊到多个操作单元进行执行，用来解决互联网分布式系统的大流量、高并发和高可用的问题。那什么是高可用呢？</p>\n<h2 id=\"2什么是高可用\">2、什么是高可用？</h2>\n<p><strong>首先了解什么是高可用？</strong></p>\n<p>这是 CAP 定理是分布式系统的基础，也是分布式系统的 3 个指标：</p>\n<ol>\n<li>Consistency（一致性）</li>\n<li>Availability（可用性）</li>\n<li>Partition tolerance（分区容错性）</li>\n</ol>\n<p>那高可用（High Availability）是什么？高可用，简称 HA，是系统一种特征或者指标，通常是指，提供一定性能上的服务运行时间，高于平均正常时间段。反之，消除系统服务不可用的时间。</p>\n<p>衡量系统是否满足高可用，就是当一台或者多台服务器宕机的时候，系统整体和服务依然正常可用。</p>\n<p>举个例子，一些知名的网站保证 4 个 9 以上的可用性，也就是可用性超过 99.99%。那 0.01% 就是所谓故障时间的百分比。比如电商网站有赞，服务不可用会造成商家损失金钱和用户。那么在提高可用性基础上同时，对系统宕机和服务不可用会有补偿。</p>\n<p>\n<img src=\"http://img.topjavaer.cn/img/负载均衡2.jpg\">\n</p>\n<p>比如下单服务，可以使用带有负载均衡的多个下单服务实例，代替单一的下单服务实例，即使用冗余的方式来提高可靠性。</p>\n<p>总而言之，负载均衡（Load Balance）是分布式系统架构设计中必须考虑的因素之一。一般通过负载均衡，冗余同一个服务实例的方式，解决分布式系统的大流量、高并发和高可用的问题。负载均衡核心关键：在于是否分配均匀。</p>\n<h2 id=\"3常见的负载均衡案例\">3、常见的负载均衡案例</h2>\n<p>\n<img src=\"http://img.topjavaer.cn/img/负载均衡3.jpg\">\n</p>\n<p>场景1：微服务架构中，网关路由到具体的服务实例 hello：</p>\n<ul>\n<li>两个相同的服务实例 hello service ，一个端口 8000 ，另一个端口 8082</li>\n<li>通过 Kong 的负载均衡 LB 功能，让请求均匀的分发到两个 hello 服务实例</li>\n<li>Kong 的负载均衡策略算法很多：默认 weighted-round-robin 算法，还有 consumer: consumer id 作为 hash 算法输入值等</li>\n</ul>\n<p>\n<img src=\"http://img.topjavaer.cn/img/负载均衡4.jpg\">\n</p>\n<p>场景2：微服务架构中，A 服务调用 B 服务的集群。通过了 Ribbon 客户端负载均衡组件：</p>\n<ul>\n<li>负载均衡策略算法并不高级，最简单的是随机选择和轮循</li>\n</ul>\n<h2 id=\"4互联网分布式系统解决方案\">4、互联网分布式系统解决方案</h2>\n<p>\n<img src=\"http://img.topjavaer.cn/img/负载均衡5.jpg\">\n</p>\n<p>常见的互联网分布式系统架构分为几层，一般如下：</p>\n<ul>\n<li>客户端层：比如用户浏览器、APP 端</li>\n<li>反向代理层：技术选型 Nignx 或者 F5 等</li>\n<li>Web 层：前后端分离场景下， Web 端可以用 NodeJS 、 RN 、Vue</li>\n<li>业务服务层：用 Java 、Go，一般互联网公司，技术方案选型就是 SC 或者 Spring Boot + Dubbo 服务化</li>\n<li>数据存储层：DB 选型 MySQL ，Cache 选型 Redis ，搜索选型 ES 等</li>\n</ul>\n<p>一个请求从第 1 层到第 4 层，层层访问都需要负载均衡。即每个上游调用下游多个业务方的时候，需要均匀调用。这样整体系统来看，就比较负载均衡</p>\n<p><strong>第 1 层：客户端层 -&gt; 反向代理层 的负载均衡</strong></p>\n<p>客户端层 -&gt; 反向代理层的负载均衡如何实现呢？</p>\n<p>答案是：DNS 的轮询。 DNS 可以通过 A （Address，返回域名指向的 IP 地址）设置多个 IP 地址。比如这里访问 <a href=\"https://link.zhihu.com/?target=http%3A//bysocket.com\" ref=\"nofollow\" target=\"_blank\">http://bysocket.comopen in new window</a><span><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"inline ml-1\" style=\"color: #aaa;\" aria-hidden=\"true\" focusable=\"false\" x=\"0px\" y=\"0px\" viewBox=\"0 0 100 100\" width=\"15\" height=\"15\" class=\"icon outbound\"><path fill=\"currentColor\" d=\"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z\"></path> <polygon fill=\"currentColor\" points=\"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9\"></polygon></svg> <span class=\"sr-only\"></span></span> 的 DNS 配置了 ip1 和 ip2 。为了反向代理层的高可用，至少会有两条 A 记录。这样冗余的两个 ip 对应的 nginx 服务实例，防止单点故障。</p>\n<p>每次请求 <a href=\"https://link.zhihu.com/?target=http%3A//bysocket.com\" ref=\"nofollow\" target=\"_blank\">http://bysocket.comopen in new window</a><span><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"inline ml-1\" style=\"color: #aaa;\" aria-hidden=\"true\" focusable=\"false\" x=\"0px\" y=\"0px\" viewBox=\"0 0 100 100\" width=\"15\" height=\"15\" class=\"icon outbound\"><path fill=\"currentColor\" d=\"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z\"></path> <polygon fill=\"currentColor\" points=\"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9\"></polygon></svg> <span class=\"sr-only\"></span></span> 域名的时候，通过 DNS 轮询，返回对应的 ip 地址，每个 ip 对应的反向代理层的服务实例，也就是 nginx 的外网ip。这样可以做到每一个反向代理层实例得到的请求分配是均衡的。</p>\n<p><strong>第 2 层：反向代理层 -&gt; Web 层 的负载均衡</strong></p>\n<p>反向代理层 -&gt; Web 层 的负载均衡如何实现呢？</p>\n<p>是通过反向代理层的负载均衡模块处理。比如 nginx 有多种均衡方法：</p>\n<ol>\n<li>请求轮询。请求按时间顺序，逐一分配到 web 层服务，然后周而复始。如果 web 层服务 down 掉，自动剔除</li>\n</ol>\n<pre><code class=\"language-text\">upstream web-server {\nserver ip3;\nserver ip4;\n}\n</code></pre>\n<p>ip 哈希。按照 ip 的哈希值，确定路由到对应的 web 层。只要是用户的 ip 是均匀的，那么请求到 Web 层也是均匀的。</p>\n<ol>\n<li>还有个好处就是同一个 ip 的请求会分发到相同的 web 层服务。这样每个用户固定访问一个 web 层服务，可以解决 session 的问题。</li>\n</ol>\n<pre><code class=\"language-text\">upstream web-server {\nip_hash;\nserver ip3;\nserver ip4;\n}\n</code></pre>\n<ol>\n<li>weight 权重 、 fair、url_hash 等</li>\n</ol>\n<p><strong>第 3 层：Web 层 -&gt; 业务服务层 的负载均衡</strong></p>\n<p>Web 层 -&gt; 业务服务层 的负载均衡如何实现呢？</p>\n<p>比如 Dubbo 是一个服务治理方案，包括服务注册、服务降级、访问控制、动态配置路由规则、权重调节、负载均衡。其中一个特性就是智能负载均衡：内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量。</p>\n<p>为了避免避免单点故障和支持服务的横向扩容，一个服务通常会部署多个实例，即 Dubbo 集群部署。会将多个服务实例成为一个服务提供方，然后根据配置的随机负载均衡策略，在20个 Provider 中随机选择了一个来调用，假设随机到了第7个 Provider。LoadBalance 组件从提供者地址列表中，使用均衡策略，选择选一个提供者进行调用，如果调用失败，再选另一台调用。</p>\n<p>Dubbo内置了4种负载均衡策略:</p>\n<ul>\n<li>RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的默认负载均衡策略。</li>\n<li>RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。</li>\n<li>LeastActiveLoadBalance:最少活跃调用数，相同活跃数的随机。活跃数指调用前后计数差。使慢的 Provider 收到更少请求，因为越慢的 Provider 的调用前后计数差会越大。</li>\n<li>ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。</li>\n</ul>\n<p>同样，因为业务的需要，也可以实现自己的负载均衡策略</p>\n<p><strong>第 4 层：业务服务层 -&gt; 数据存储层 的负载均衡</strong></p>\n<p>数据存储层的负载均衡，一般通过 DBProxy 实现。比如 MySQL 分库分表。</p>\n<p>当单库或者单表访问太大，数据量太大的情况下，需要进行垂直拆分和水平拆分两个维度。比如水平切分规则：</p>\n<ul>\n<li>Range 、 时间</li>\n<li>hash 取模，订单根据店铺ID 等</li>\n</ul>\n<p>但伴随着这块的负载会出现下面的问题，需要解决：</p>\n<ul>\n<li>分布式事务</li>\n<li>跨库 join 等</li>\n</ul>\n<p>现状分库分表的产品方案很多：当当 sharding-jdbc、阿里的 Cobar 等</p>\n<h2 id=\"5小结\">5、小结</h2>\n<p>对外看来，负载均衡是一个系统或软件的整体。对内看来，层层上下游调用。只要存在调用，就需要考虑负载均衡这个因素。所以负载均衡（Load Balance）是分布式系统架构设计中必须考虑的因素之一。考虑主要是如何让下游接收到的请求是均匀分布的：</p>\n<ul>\n<li>第 1 层：客户端层 -&gt; 反向代理层 的负载均衡。通过 DNS 轮询</li>\n<li>第 2 层：反向代理层 -&gt; Web 层 的负载均衡。通过 Nginx 的负载均衡模块</li>\n<li>第 3 层：Web 层 -&gt; 业务服务层 的负载均衡。通过服务治理框架的负载均衡模块</li>\n<li>第 4 层：业务服务层 -&gt; 数据存储层 的负载均衡。通过数据的水平分布，数据均匀了，理论上请求也会均匀。比如通过买家ID分片类似</li>\n</ul>\n","createTime":"2024-07-19 22:46:47","categoryId":41,"categoryName":"高可用","readNum":1,"tags":[{"id":71,"name":"微服务","articlesTotal":null},{"id":73,"name":"高可用","articlesTotal":null},{"id":74,"name":"系统设计","articlesTotal":null}],"preArticle":null,"nextArticle":{"articleId":58,"articleTitle":"JMM"},"totalWords":2338,"readTime":"约 7 分钟","updateTime":"2024-07-19 22:48:20"}} =================================== 
2024-07-22 22:27:09.594 [http-nio-8088-exec-5] INFO  c.j.w.f.b.c.filter.HeaderUserId2ContextFilter - ===== 删除 ThreadLocal， userId: 1
2024-07-22 22:29:16.067 [nacos-grpc-client-executor-110.41.141.141-22760] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - [1721653315191_115.233.205.187_40501]Request stream error, switch server,error={}
com.alibaba.nacos.shaded.io.grpc.StatusRuntimeException: UNAVAILABLE: io exception
	at com.alibaba.nacos.shaded.io.grpc.Status.asRuntimeException(Status.java:539)
	at com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$StreamObserverToCallListenerAdapter.onClose(ClientCalls.java:487)
	at com.alibaba.nacos.shaded.io.grpc.internal.ClientCallImpl.closeObserver(ClientCallImpl.java:563)
	at com.alibaba.nacos.shaded.io.grpc.internal.ClientCallImpl.access$300(ClientCallImpl.java:70)
	at com.alibaba.nacos.shaded.io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInternal(ClientCallImpl.java:744)
	at com.alibaba.nacos.shaded.io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:723)
	at com.alibaba.nacos.shaded.io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
	at com.alibaba.nacos.shaded.io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
Caused by: java.net.SocketException: Connection reset
	at java.base/sun.nio.ch.SocketChannelImpl.throwConnectionReset(SocketChannelImpl.java:394)
	at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:426)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.buffer.PooledByteBuf.setBytes(PooledByteBuf.java:258)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1132)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:357)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:151)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
2024-07-22 22:29:16.070 [nacos-grpc-client-executor-110.41.141.141-22759] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - [1721653312292_115.233.205.187_47078]Request stream error, switch server,error={}
com.alibaba.nacos.shaded.io.grpc.StatusRuntimeException: UNAVAILABLE: io exception
	at com.alibaba.nacos.shaded.io.grpc.Status.asRuntimeException(Status.java:539)
	at com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$StreamObserverToCallListenerAdapter.onClose(ClientCalls.java:487)
	at com.alibaba.nacos.shaded.io.grpc.internal.ClientCallImpl.closeObserver(ClientCallImpl.java:563)
	at com.alibaba.nacos.shaded.io.grpc.internal.ClientCallImpl.access$300(ClientCallImpl.java:70)
	at com.alibaba.nacos.shaded.io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInternal(ClientCallImpl.java:744)
	at com.alibaba.nacos.shaded.io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:723)
	at com.alibaba.nacos.shaded.io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
	at com.alibaba.nacos.shaded.io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
Caused by: java.net.SocketException: Connection reset
	at java.base/sun.nio.ch.SocketChannelImpl.throwConnectionReset(SocketChannelImpl.java:394)
	at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:426)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.buffer.PooledByteBuf.setBytes(PooledByteBuf.java:258)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1132)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:357)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:151)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
2024-07-22 22:29:16.071 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [ca51fe5a-6020-492e-8060-90db6cd52b8f_config-0] Server healthy check fail, currentConnection = 1721653312292_115.233.205.187_47078
2024-07-22 22:29:16.071 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [ca51fe5a-6020-492e-8060-90db6cd52b8f_config-0] Try to reconnect to a new server, server is  not appointed, will choose a random server.
2024-07-22 22:29:16.071 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:19.093 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [b8f5effd-c7fd-43fc-b20a-e009c2103983] Server healthy check fail, currentConnection = 1721653315191_115.233.205.187_40501
2024-07-22 22:29:19.093 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [b8f5effd-c7fd-43fc-b20a-e009c2103983] Try to reconnect to a new server, server is  not appointed, will choose a random server.
2024-07-22 22:29:19.093 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:19.093 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 12 milliseconds, 249100 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@720b68da[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:19.204 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:22.109 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 14 milliseconds, 5800 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@22be4d2c[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:22.219 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:22.219 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 12 milliseconds, 594700 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@52d2ecea[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:22.219 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [ca51fe5a-6020-492e-8060-90db6cd52b8f_config-0] Fail to connect server, after trying 1 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:22.425 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:25.230 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 7 milliseconds, 382100 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@74378212[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:25.230 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [b8f5effd-c7fd-43fc-b20a-e009c2103983] Fail to connect server, after trying 1 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:25.438 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:25.438 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 9 milliseconds, 922700 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@7c8c8691[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:25.440 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [ca51fe5a-6020-492e-8060-90db6cd52b8f_config-0] Fail to connect server, after trying 2 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:25.742 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:28.448 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 5 milliseconds, 766600 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@d773502[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:28.448 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [b8f5effd-c7fd-43fc-b20a-e009c2103983] Fail to connect server, after trying 2 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:28.752 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:28.752 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 7 milliseconds, 679900 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@7b821bea[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:28.752 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [ca51fe5a-6020-492e-8060-90db6cd52b8f_config-0] Fail to connect server, after trying 3 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:29.155 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:31.767 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 13 milliseconds, 78400 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@42909151[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:31.767 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [b8f5effd-c7fd-43fc-b20a-e009c2103983] Fail to connect server, after trying 3 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:32.166 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 8 milliseconds, 675100 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@369bf964[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:32.167 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [ca51fe5a-6020-492e-8060-90db6cd52b8f_config-0] Fail to connect server, after trying 4 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:32.182 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:32.675 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:35.195 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 9 milliseconds, 523800 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@78746b08[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:35.196 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [b8f5effd-c7fd-43fc-b20a-e009c2103983] Fail to connect server, after trying 4 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:35.688 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 9 milliseconds, 254200 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@17997673[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:35.689 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [ca51fe5a-6020-492e-8060-90db6cd52b8f_config-0] Fail to connect server, after trying 5 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:35.703 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:36.293 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:38.714 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 8 milliseconds, 917300 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@77e70ea7[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:38.714 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [b8f5effd-c7fd-43fc-b20a-e009c2103983] Fail to connect server, after trying 5 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:39.299 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 3 milliseconds, 646700 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@71b33786[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:39.299 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [ca51fe5a-6020-492e-8060-90db6cd52b8f_config-0] Fail to connect server, after trying 6 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:39.315 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:40.002 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:42.324 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 7 milliseconds, 246500 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@2c6f255a[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:42.324 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [b8f5effd-c7fd-43fc-b20a-e009c2103983] Fail to connect server, after trying 6 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:43.008 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 3 milliseconds, 210000 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@79dabb0d[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:43.009 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [ca51fe5a-6020-492e-8060-90db6cd52b8f_config-0] Fail to connect server, after trying 7 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:43.037 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:43.814 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:46.041 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 702100 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@391dacce[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:46.044 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [b8f5effd-c7fd-43fc-b20a-e009c2103983] Fail to connect server, after trying 7 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:46.821 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 3 milliseconds, 813000 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@53bf5182[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:46.822 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [ca51fe5a-6020-492e-8060-90db6cd52b8f_config-0] Fail to connect server, after trying 8 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:46.846 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:47.727 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:49.896 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 48 milliseconds, 265200 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@76a4ab87[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:49.896 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [b8f5effd-c7fd-43fc-b20a-e009c2103983] Fail to connect server, after trying 8 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:50.732 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.TimeoutException: Waited 3000 milliseconds (plus 1 milliseconds, 892800 nanoseconds delay) for com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$GrpcFuture@1f03bd4a[status=PENDING, info=[GrpcFuture{clientCall=PendingCall{realCall=ClientCallImpl{method=MethodDescriptor{fullMethodName=Request/request, type=UNARY, idempotent=false, safe=false, sampledToLocalTracing=true, requestMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@6768daed, responseMarshaller=com.alibaba.nacos.shaded.io.grpc.protobuf.lite.ProtoLiteUtils$MessageMarshaller@3f243d4f, schemaDescriptor=com.alibaba.nacos.api.grpc.auto.RequestGrpc$RequestMethodDescriptorSupplier@32aa7757}}}}]]
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:508)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:50.733 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [ca51fe5a-6020-492e-8060-90db6cd52b8f_config-0] Fail to connect server, after trying 9 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
2024-07-22 22:29:50.808 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:51.743 [com.alibaba.nacos.client.remote.worker] INFO  c.a.nacos.common.remote.client.grpc.GrpcClient - grpc client connection server:110.41.141.141 ip,serverPort:9848,grpcTslConfig:{"sslProvider":"OPENSSL","enableTls":false,"mutualAuthEnable":false,"trustAll":false}
2024-07-22 22:29:52.999 [com.alibaba.nacos.client.remote.worker] ERROR c.a.nacos.common.remote.client.grpc.GrpcClient - Server check fail, please check server 110.41.141.141 ,port 9848 is available , error ={}
java.util.concurrent.ExecutionException: com.alibaba.nacos.shaded.io.grpc.StatusRuntimeException: UNAVAILABLE: io exception
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.getDoneValue(AbstractFuture.java:566)
	at com.alibaba.nacos.shaded.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:445)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.serverCheck(GrpcClient.java:218)
	at com.alibaba.nacos.common.remote.client.grpc.GrpcClient.connectToServer(GrpcClient.java:329)
	at com.alibaba.nacos.common.remote.client.RpcClient.reconnect(RpcClient.java:502)
	at com.alibaba.nacos.common.remote.client.RpcClient.lambda$start$2(RpcClient.java:343)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
Caused by: com.alibaba.nacos.shaded.io.grpc.StatusRuntimeException: UNAVAILABLE: io exception
	at com.alibaba.nacos.shaded.io.grpc.Status.asRuntimeException(Status.java:539)
	at com.alibaba.nacos.shaded.io.grpc.stub.ClientCalls$UnaryStreamToFuture.onClose(ClientCalls.java:544)
	at com.alibaba.nacos.shaded.io.grpc.internal.DelayedClientCall$DelayedListener$3.run(DelayedClientCall.java:471)
	at com.alibaba.nacos.shaded.io.grpc.internal.DelayedClientCall$DelayedListener.delayOrExecute(DelayedClientCall.java:435)
	at com.alibaba.nacos.shaded.io.grpc.internal.DelayedClientCall$DelayedListener.onClose(DelayedClientCall.java:468)
	at com.alibaba.nacos.shaded.io.grpc.internal.ClientCallImpl.closeObserver(ClientCallImpl.java:563)
	at com.alibaba.nacos.shaded.io.grpc.internal.ClientCallImpl.access$300(ClientCallImpl.java:70)
	at com.alibaba.nacos.shaded.io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInternal(ClientCallImpl.java:744)
	at com.alibaba.nacos.shaded.io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:723)
	at com.alibaba.nacos.shaded.io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
	at com.alibaba.nacos.shaded.io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
	... 3 common frames omitted
Caused by: com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: no further information: /110.41.141.141:9848
Caused by: java.net.ConnectException: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:946)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:337)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:710)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024-07-22 22:29:53.013 [com.alibaba.nacos.client.remote.worker] INFO  com.alibaba.nacos.common.remote.client - [b8f5effd-c7fd-43fc-b20a-e009c2103983] Fail to connect server, after trying 9 times, last try server is {serverIp = '110.41.141.141', server main port = 8848}, error = unknown
